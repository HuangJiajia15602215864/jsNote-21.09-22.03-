/*
https://juejin.cn/post/6995706341041897486#heading-16
1、引用法
判断一个对象的引用数，引用数为0就回收，引用数大于0就不回收
缺点：互相引用的对象不能被回收
*/
function fn () {
  const obj1 = {}
  const obj2 = {}
  obj1.a = obj2
  obj2.a = obj1
}
fn()

/*
2、标记法
将可达的对象标记起来，不可达的对象当成垃圾回收
可达对象：从初始的根对象（window或者global）的指针开始，向下搜索子节点，子节点被搜索到了，说明该子节点的引用对象可达，并为其进行标记；然后接着递归搜索，直到所有子节点被遍历结束。那么没有被遍历到节点，也就没有被标记，可以被垃圾回收器回收。
*/
// 可达
var name = '林三心'
var obj = {
  arr: [1, 2, 3]
}
console.log(window.name) // 林三心
console.log(window.obj) // { arr: [1, 2, 3] }
console.log(window.obj.arr) // [1, 2, 3]
console.log(window.obj.arr[1]) // 2

// 不可达
function fn () {
  var age = 22
}
console.log(window.age) // undefined

/*
JavaScript内存管理:
1、分配给使用者所需的内存(使用者:变量)
2、使用者拿到这些内存，并使用内存
3、使用者不需要这些内存了，释放并归还给系统

基础数据类型：拥有固定的大小，值保存在栈内存里，可以通过值直接访问
引用数据类型：大小不固定(可以加属性)，栈内存中存着指针，指向堆内存中的对象空间，通过引用来访问

栈内存：所存的基础数据类型大小是固定的，所以栈内存的内存都是操作系统自动分配和释放回收的
堆内存：所存大小不固定，系统无法自动释放回收，所以需要JS引擎来手动释放这些内存；当我们的代码没有按照正确的写法时，会使得JS引擎的垃圾回收机制无法正确的对内存进行释放（内存泄露）
*/



